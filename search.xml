<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js模块化发展历程]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[模块化是指把一个复杂的系统分解到一个一个的模块。 模块化开发的优点：(1)代码复用，让我们更方便地进行代码管理、同时也便于后面代码的修改和维护。 (2)一个单独的文件就是一个模块，是一个单独的作用域，只向外暴露特定的变量和函数。这样可以避免污染全局变量，减少变量命名冲突。 js模块化规范有：CommonJS、AMD、CMD、ES6的模块系统。本文将依次介绍下每个规范。 一、早期：用script来引入js模块1234&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt; 缺点：(1)加载的时候会停止渲染网页，引入的js文件越多，网页失去响应的时间越长； (2)会污染全局变量； (3)js文件之间存在依赖关系，加载是有顺序的，依赖性最大的要放到最后去加载；当项目规模较大时，依赖关系变得错综复杂。 (4)要引入的js文件太多，不美观，代码难以管理。 二、CommonJS 规范是服务器端模块的规范，由nodejs推广使用。该规范的核心思想是：允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或module.exports 来导出需要暴露的接口。 CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过 exports.xx = xx 的方式导出，CommonJS2 在 CommonJS1 的基础上加入了module.exports = xx 的导出方式。 CommonJS 通常指 CommonJS2。 采用CommonJS 规范导入导出： 1234// 导出module.exports = moduleA.someFunc;// 导入const moduleA = require('./moduleA'); 实例： 12345678910//math.jsvar num = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //需要向外暴露的变量、函数 num: num, add: add&#125; 可以这样加载： 1234//引入自定义的模块时，参数包含路径，可省略.js//引入核心模块时，不需要带路径，如var http = require("http");var math = require('./math');math.add(1, 2)//3 实际上，从上面的例子就可以看出，math.add(1,2)必须要等待math.js加载完成，即require是同步的。 在服务器端，模块文件保存在本地磁盘，等待时间就是磁盘的读取时间。但对于浏览器而言，由于模块都放在服务器端，等待时间取决于网上的快慢。因此更合理的方案是异步加载模块。 缺点：(1)不能并行加载模块，会阻塞浏览器加载； (2)代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5； 三、AMD和require.jsAMD：异步模块定义。上面已经介绍过，CommonJS是服务器端模块的规范，主要是为了JS在后端的表现制定的，不太适合前端。而AMD就是要为前端JS的表现制定规范。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是require.js（还有个js库：curl.js）。实际上AMD 是 require.js在推广过程中对模块定义的规范化的产出。 AMD采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 require.js也采用require()语句加载模块，但是不同于CommonJS： 12345678// 定义一个模块define('module', ['dep'], function (dep) &#123; return exports;&#125;);// 导入和使用require(['module'], function (module) &#123;&#125;); 上面示例中的代码改写成AMD形式： math.js定义一个模块: 1234567define('math', ['jquery'], function (jquery) &#123;//引入jQuery模块 return &#123; add: function (x, y) &#123; return x + y; &#125; &#125;;&#125;); 导入和使用： 123require(['math'], function (math) &#123; math.add(1, 2)&#125;) math.add()与加载math模块不是同步的，不会阻塞浏览器的加载。 四、CMD和sea.jsCMD：通用模块定义。 国内的玉伯大佬写了sea.js，实际上CMD就是 sea.js在推广过程中对模块定义的规范化的产出。 123define(function (require, exports, module) &#123; // 模块代码&#125;); 说明： require：可以把其他模块导入进来的一个参数； exports：可以把模块内的一些属性和方法导出的； module： 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 上面示例中的代码改写成AMD形式： 1234567891011define(function (require, exports, module) &#123; var add = function (a, b) &#123; return a + b; &#125; exports.add = add;&#125;)//导入和使用seajs.use(['math.js'], function (math) &#123; var sum = math.add(1, 2);&#125;); CMD与AMD的不同的在于：(1)AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require： 12345678910111213141516171819//AMD推崇的依赖关系前置：在定义模块时就要声明要依赖的模块define(['a', 'b', 'c', 'd'], function (a, b, c, d) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处省略100行 ... b.doSomething() ...&#125;)//CMD推崇依赖就近，按需加载，只有在用到某个模块时再去requiredefine(function (require, exports, modules) &#123; var a = require('a'); a.doSomething(); // 此处省略100行 ... var b = require("b");//按需加载 b.doSomething(); ...&#125;) (2)AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。 对于依赖的模块，AMD是提前执行，CMD是延迟执行。 具体细节可点击与 RequireJS 的异同 五、ES6模块化ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 在 ES6 中，使用export关键字来导出模块，使用import关键字引用模块。但是浏览器还没有完全兼容，需要使用babel转换成ES5。 12345678// 导出export function hello() &#123; &#125;;export default &#123; // ...&#125;;// 导入import &#123; readFile &#125; from 'fs';import React from 'react'; 使用import导入模块时，需要知道要加载的变量名或函数名。 在ES6中还提供了export default，为模块指定默认输出.对应导入模块import时，不需要使用大括号。 上面示例中的代码改写成ES6形式： 123456789101112//math.jsvar num = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; num, add &#125;;//导入import &#123; num, add &#125; from './math';function test(ele) &#123; ele.textContent = add(1 + num);&#125; 缺点浏览器还没有完全兼容，必须通过工具转换成标准的 ES5 后才能正常运行。 小结本文从script引入js文件讲起，到服务器端模块的规范CommonJs，再到推崇依赖前置的浏览器端模块的规范AMD、推崇依赖就近的浏览器端模块的规范CMD，最后介绍了ES6的模块化。每个介绍中都有各规范基本的用法和一个示例。如有问题，欢迎指正。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-asset-image插件引用本地图片无法显示]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E4%BD%BF%E7%94%A8hexo-asset-image%E6%8F%92%E4%BB%B6%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[启用文章资源文件夹功能： 1.修改站点配置文件_config.yml：post_asset_folder: true 2.安装一个可以上传本地图片的插件：npm install hexo-asset-image --save 3.以后使用hexo new &#39;xxxx&#39;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4.当我们在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![](图片名.jpg) 在文章里面插入图片，hexo g生成的时候总会在图片前面插一个.io，hexo s运行后图片并没有正常显示出来，在网上查找后发现是hexo-asset-image这个插件的bug，hexo版本3.0以上获取网站url的方式与3.0以下有些不同。 解决办法：打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行gulp项目报错：AssertionError [ERR_ASSERTION]: Task function must be specified]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F%E8%BF%90%E8%A1%8Cgulp%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%EF%BC%9AAssertionError-ERR-ASSERTION-Task-function-must-be-specified%2F</url>
    <content type="text"><![CDATA[今天写了一篇文章正准备发布，生成静态资源文件后使用gulp bulid压缩代码，但是一运行：gulp 出现了这个错误： 12345678910111213141516$ gulp buildassert.js:339 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (E:\Documents\GitHub\blog\node_modules\undertaker\lib\set-task.js:10:3) at Gulp.task (E:\Documents\GitHub\blog\node_modules\undertaker\lib\task.js:13:8) at Object.&lt;anonymous&gt; (E:\Documents\GitHub\blog\gulpfile.js:43:6) at Module._compile (internal/modules/cjs/loader.js:776:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Module.require (internal/modules/cjs/loader.js:690:17) at require (internal/modules/cjs/helpers.js:25:18) gulp项目需要全局安装gulp和项目内安装gulp 通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 123$ gulp -vCLI version: 3.9.1Local version: 4.0.2 查看package.json文件果然：&quot;gulp&quot;: &quot;^4.0.2&quot;, 因为本地的gulp更新到了版本4，而gulpfile.js用的是gulp3.9.1的语法 解决方案一：npm i gulp@3.9.1 重新安装gulp到3.9.1版 解决方案二：按gulp4的语法重写gulpfile.js任务列表]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OffscreenCanvas - 概念说明及使用解析]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FOffscreenCanvas-%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[OffscreenCanvas 是一个实验中的新特性，主要用于提升 Canvas 2D/3D 绘图应用和 H5 游戏的渲染性能和使用体验。OffscreenCanvas 的 API 很简单，但是要真正掌握好如何使用，需要页端对浏览器内部的一些运作机制有较深入的了解，这也是撰写本文的目的。 跟 OffscreenCanvas 关系比较紧密的还有另外两个新的 API，ImageBitmap 和 ImageBitmapRenderingContext，在文中也会一并进行讲解。 目前 OffscreenCanvas 在最新版本的 Chrome 和 Firefox 上都可以通过实验室开关打开，Chrome 的开关是 chome://flags -&gt; Experimental Web Platform features，本文的例程是在 Chrome 67 Canary 上进行验证。OffscreenCanvas 的 API 在未来仍有可能会发生一些变化，本文会随之进行更新。 概念说明Chrome 开发文档里面对 OffscreenCanvas 的定义是： A new interface that allows canvas rendering contexts (2D and WebGL) to be used in workers.Making canvas rendering contexts available to workers will increase parallelism in web applications, leading to increased performance on multi-core systems. 简单的说，就是你现在可以在 Worker 线程调用 Canvas API 啦，通过在 Worker 线程完成 Canvas 渲染任务，可以提升 WebApp 的并发程度，从而提升性能和使用体验，balabala… 不过 JavaScript 目前并没有提供一个真正可用的多线程并发编程模型，缺少了互斥，信号量等同步原语，线程间无法共享数据，所以除了一些很特定的应用场景，并且需要页端对应用/游戏的引擎设计做出较大的修改，大部分场景下指望简单地使用 OffscreenCanvas 然后就能获得并发带来的大幅性能提升其实并不太现实。不过即使应用/游戏无法有效地使用 OffscreenCanvas 来实现自身的多线程并发运行，OffscreenCanvas 仍然提供了很高的使用价值，也让浏览器有机会优化自身的 Canvas 渲染流水线，下文会通过例程来讲解如何在实际的应用场景中有效地使用 OffscreenCanvas。 当然你还是可以在主线程使用 OffscreenCanvas，并且即使在主线程使用，取决于应用的场景，也还是可能会带来一些收益。JavaScript 未来也许会增加多线程共享数据，数据访问同步的支持，但是起码目前是没有的。 使用解析OffscreenCanvas 目前主要用于两种不同的使用场景： 一种是在 Worker 线程创建一个 OffscreenCanvas 做后台渲染，然后再把渲染好的缓冲区 Transfer 回主线程显示； 一种是主线程从当前 DOM 树中的 Canvas 元素产生一个 OffscreenCanvas，再把这个 OffscreenCanvas 发送给 Worker 线程进行渲染，渲染的结果直接 Commit 到浏览器的 Display Compositor 输出到当前窗口，相当于在 Worker 线程直接更新 Canvas 元素的内容； 我自己把第一种使用方式称之为 Transfer 模式，第二种使用方式称之为 Commit 模式。 Transfer 模式 Transfer Demo，使用 Transfer 模式 Transfer 模式主要用于后台渲染，避免耗时的渲染任务会阻塞前台线程，导致应用无法及时响应用户的操作，比如一些 2D/3D 图表，图形可视化应用，地图应用等。 实际上这是 OffscreenCanvas 这个特性的最早需求，来自于 Google Map 团队。 Transfer Demo 运行流程大致如下： 主线程启动 Worker 线程，并请求初始化； Worker 线程创建 OffscreenCanvas； Worker 线程获取 OffscreenCanvas 的 WebGL Context 并进行绘制； Worker 线程获取 OffscreenCanvas 的缓冲区（ImageBitmap），然后 Transfer 回主线程； 主线程将 Worker 线程回传的缓冲区分别绘制在两个不同的 Canvas 上，一个 Canvas 使用 CanvasRenderingContext2D，一个 Canvas 使用 ImageBitmapRenderingContext； 3 ~ 5 重复运行； 代码解析下面是一些主要步骤的代码，展示了 OffscreenCanvas，ImageBitmap，ImageBitmapRenderingContext API 的使用。 在 Worker 线程创建 OffscreenCanvas 12345function Init(mode, data) &#123; if (mode === "transfer") canvas = new OffscreenCanvas(data.width, data.height); ...&#125; 获取 OffscreenCanvas 的缓冲区并回传 12345function TransferBuffer() &#123; let image_bitmap = canvas.transferToImageBitmap(); postMessage(&#123;name:"TransferBuffer", buffer:image_bitmap&#125;, [image_bitmap]);&#125; 主线程接收回传的缓冲区并绘制 12345678910111213141516171819g_render_worker.onmessage = function(msg) &#123; if (msg.data.name === "TransferBuffer") &#123; GetTransferBuffer(msg.data.buffer); &#125;&#125;function GetTransferBuffer(buffer) &#123; let context_2d = g_2d_canvas.getContext("2d"); context_2d.clearRect(0, 0, g_2d_canvas.width, g_2d_canvas.height); context_2d.save(); ... context_2d.drawImage(buffer, 0, 0); context_2d.restore(); ... let bitmap_context = g_bitmap_canvas.getContext("bitmaprenderer"); bitmap_context.transferFromImageBitmap(buffer);&#125; ImageBitmap 和 ImageBitmapRenderingContext上面的例程使用到了 ImageBitmap 和 ImageBitmapRenderingContext，它们到底是什么，跟 ImageData 和 CanvasRenderingContext2D 又有什么不同？ ImageBitmap 主要是用来封装一块 GPU 缓冲区，可以被 GPU 读写，并且实现了 Transferable 的接口，可以在不同线程之间 Transfer。跟 ImageData 不一样，ImageBitmap 并没有提供 JavaScipt API 供 CPU 进行读写，这是因为使用 CPU 读写 GPU 缓冲区的成本非常高，需要拷贝到临时缓冲区进行读写然后再写回。这也是为什么规范的制定者没有扩展 ImageData，而是提供了一个新的 ImageBitmap 的缘故。 ImageBitmap 可以被当做普通的 Image 绘制在一个 2D Canvas 上，也可以通过 ImageBitmapRenderingContext Transfer 到一个 Bitmap Canvas，我们通过举例来说明这两种方式的区别： 但我们使用 OffscreenCanvas，通过 2D/3D 进行绘制时，就好像我们有一块画板，上面有一些画纸，我们可以在画纸上作画； 调用 OffscreenCanvas.transferToImageBitmap 获取 ImageBitmap 封装的缓冲区，就好像我们把当前绘画的画纸取下来； 把 ImageBitmap 作为 Image 绘制在一个 2D Canvas 上，就好像我们对已经绘制好的图画在新的画纸上进行临摹； 把 ImageBitmap 通过 ImageBitmapRenderingContext.transferFromImageBitmap Transfer 给 Bitmap Canvas，就好像我们把画纸放入一个画框里挂在墙上显示； 简单的说 ImageBitmap Transfer 语义实现了 Zero Copy 的所有权转移，不需要对缓冲区进行拷贝，性能更高，但是也限制了显示的方式，而临摹意味着我们可以对临摹的副本进行旋转，缩放，位移等等，还可以在上面再绘制其它内容。另外 ImageBitmap Transfer 之后所有权就发生了转移，比如 Transfer Demo 的例程调换一下两个 Canvas 的绘制顺序就会报错，这是因为 Transfer 之后，原来的缓冲区引用已经被置空变成一个空引用。 具体使用哪种方式取决于应用的场景，如果只是简单的展现就可以考虑使用性能更高 ImageBitmapRenderingContext，OffscreenCanvas，加 ImageBitmap，加 ImageBitmapRenderingContext 提供了一种最高效的后台渲染，前台展现的方式。 Commit 模式Commit 模式主要用于 H5 游戏，它允许应用/游戏在 Worker 线程直接对 DOM 树里面的 Canvas 元素进行更新，浏览器在这种模式下提供了一条最短路径和最佳性能的 Canvas 渲染流水线。 要理解浏览器所做的优化，我们首先要了解普通 Canvas 元素更新的渲染流水线，跟其它 DOM 元素一样，Canvas 元素的更新也是走非合成器动画的渲染流水线，主要的缺点是： 非合成器动画的渲染流水线比较复杂和冗长，有较多的 Overhead，页面的结构越复杂，Overhead 就越高； 如果同时有其它 DOM 元素一起更新，Canvas 的更新会被其它 DOM 元素的光栅化所阻塞，导致性能下降，性能下降的幅度取决于其它 DOM 元素光栅化的耗时； 如果我们调用 Commit，并且 Commit 的 OffscreenCanvas 是跟当前 DOM 树里面的某个 Canvas 元素相关联，浏览器就会直接将 OffscreenCanvas 的当前绘制缓冲区发送给 Display Compositor，然后 Display Compositor 就会合成新的一帧输出到当前窗口，对浏览器来说这就是最短的渲染路径。 在 Worker 线程使用 Commit 模式，理论上我们会： 避免被主线程的其它任务所阻塞，Worker 线程可以完全专注在 Canvas 动画的运行上； 通过 OffscreenCanvas 更新 Canvas 元素，浏览器走的是最短的渲染路径，避免了非合成器动画的冗长流水线和 Overhead； 如果有其它 DOM 元素同时更新，不会阻塞 OffscreenCanvas 的更新，所以通过 OffscreenCanvas，的确实现了 Canvas 更新和其它 DOM 更新的并发运行； 如果 DOM 元素需要处理事件，这些事件处理不会被 Worker 线程所阻塞，只是处理的结果数据可能需要发送给 Worker 线程用于后续的绘制； 使用 OffscreenCanvas Commit 模式的副作用是 OffscreenCanvas 的更新和其它 DOM 元素的更新不再是强制同步的，即使它们是同时更新，甚至都在主线程而不使用 Worker 线程，因为两者已经分别走了不同的流水线，最后呈现在屏幕的时机也可能不会完全一致。如果一定要求同步，就只能参考 Transfer Demo 的做法，将绘制后的缓冲区 Transfer 给 Bitmap Canvas 来显示，但是这样就无法发挥 Commit 模式的性能优势了。 如果页面除了一个 Canvas 元素外没有其它 DOM 元素，理论上 OffscreenCanvas 能够带来的性能提升也比较有限，当然蚊子肉再少也是肉，能提升一点也是好的。 Commit Demo 的运行流程大致如下： 主线程从当前 DOM 树中的 Canvas 元素生成 OffscreenCanvas； 主线程启动 Worker 线程并初始化，OffscreenCanvas 作为初始化的参数被 Transfer； Worker 线程接收 OffscreenCanvas 后完成初始化； Worker 线程使用 WebGL 对 OffscreenCanvas 进行绘制； Worker 线程绘制完成后 Commit，然后等待浏览器的回调； Worker 线程接收到到浏览器的回调后继续绘制下一帧，重复 4 ~ 6； 代码解析启动 Worker 线程并初始化 12345g_render_worker = new Worker("../common/render.js");let offscreen = g_offscreen_canvas.transferControlToOffscreen();g_render_worker.postMessage( &#123;name:"Init", mode:"commit", canvas:offscreen&#125;, [offscreen]); Commit 然后等待回调 12345678function renderloop() &#123; // Render buffer first render(); // Wait next begin frame to loop gl.commit().then(renderloop);&#125;renderloop(); 动画驱动在 Worker 线程驱动 OffscreenCanvas 动画有很多方式，比如使用传统的 Timer 和 rAF 的方式。 如果使用 Timer，我们可以在 Worker 线程直接使用，参考 Transfer Demo 的例子； 如果使用 rAF，我们需要在主线程先获得 rAF 回调，然后再通知 Worker 线程； 这两种方式各有其缺陷，都不是理想的选择。 上面的例程展示了新的动画方式，gl.commit() 返回了一个 Promise 对象，它会在下一次 Begin Frame 时被 resolve，Begin Frame 基本上可以认为是浏览器环境下的 vSync 信号，浏览器会在 Begin Frame 的过程中调用 rAF 的回调，resolve Commit Promise。因为目前 Worker 线程并不支持 rAF，所以后者就是我们当前最好的选择。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>OffscreenCanvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OffscreenCanvas - 使用Web Worker加速您的Canvas操作]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FOffscreenCanvas-%E4%BD%BF%E7%94%A8Web-Worker%E5%8A%A0%E9%80%9F%E6%82%A8%E7%9A%84Canvas%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[现在，您可以使用OffscreenCanvas从主线程渲染图形！ Canvas是一种在屏幕上绘制各种图形的流行方式，也是WebGL世界的切入点。它可用于绘制形状，图像，运行动画，甚至显示和处理视频内容。它通常用于在富媒体网络应用程序和在线游戏中创建出色的用户体验。 它是可编写脚本的，这意味着画布上绘制的内容可以通过编程方式创建，例如，在JavaScript中。这赋予画布很大的灵活性。 同时，在现代网站中，脚本执行是用户响应问题最常见的 来源之一。因为画布逻辑和渲染发生在与用户交互相同的线程上，动画中涉及的（有时很重）计算会损害应用程序的真实和感知性能。 幸运的是，OffscreenCanvas 是对这种威胁的回应！ 到目前为止，画布绘制功能与&lt;canvas&gt;元素绑定，这意味着它直接取决于DOM。顾名思义，OffscreenCanvas通过将其移出屏幕来解耦DOM和Canvas API。 由于这种解耦，OffscreenCanvas的渲染与DOM完全分离，因此在常规画布上提供了一些速度提升，因为两者之间没有同步。但更重要的是，它可以在Web Worker中使用，即使没有可用的DOM。这可以实现各种有趣的用例。 在Worker中使用OffscreenCanvasWorker 是网络的线程版本 - 它们允许您在后台运行任务。将一些脚本移动到Worker可以为应用程序提供更多空间，以便在主线程上执行用户关键任务。到目前为止，没有办法在Worker中使用Canvas API，因为没有可用的DOM。 OffscreenCanvas不依赖于DOM，因此可以使用它。在这里，我使用OffscreenCanvas来计算worker中的渐变颜色： 12345678910111213141516// file: worker.jsfunction getGradientColor(percent) &#123; const canvas = new OffscreenCanvas(100, 1); const ctx = canvas.getContext('2d'); const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0); gradient.addColorStop(0, 'red'); gradient.addColorStop(1, 'blue'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, ctx.canvas.width, 1); const imgd = ctx.getImageData(0, 0, ctx.canvas.width, 1); const colors = imgd.data.slice(percent * 4, percent * 4 + 4); return `rgba($&#123;colors[0]&#125;, $&#123;colors[1]&#125;, $&#123;colors[2]&#125;, $&#123;colors[])`;&#125;getGradientColor(40); // rgba(152, 0, 104, 255 ) 取消阻止主线程将大量计算移动到Worker时，可以释放主线程上的大量资源，这会变得更加有趣。我们可以使用transferControlToOffscreen 方法将常规画布镜像到OffscreenCanvas实例。应用于OffscreenCanvas的操作将自动在源画布上呈现。 123const offscreen = document.querySelector('canvas').transferControlToOffscreen();const worker = new Worker('myworkerurl.js');worker.postMessage(&#123; canvas: offscreen &#125;, [offscreen]); OffscreenCanvas是可转让的。除了将其指定为消息中的字段之外，还需要将其作为postMessage（转移）中的第二个参数传递，以便可以在Worker上下文中使用它。 在下面的示例中，当颜色主题发生变化时会发生“繁重计算” - 即使在快速桌面上也应该花费几毫秒。您可以选择在主线程或Worker线程上运行动画。在主线程的情况下，当繁重的任务运行时，您无法与按钮交互 - 线程被阻止。对于Worker，对UI响应性没有影响。 示例：keep-ui-responsive 它也是另一种方式：繁忙的主线程不会影响在worker上运行的动画。尽管有主要的线程流量，您仍可以使用此功能来避免视觉抖动并保证流畅的动画： 示例 在常规画布的情况下，当主线程被人为地过度工作时动画停止，而基于Worker的OffscreenCanvas播放顺利。 与流行的库一起使用由于OffscreenCanvas API通常与常规Canvas元素兼容，因此您可以轻松地将其用作渐进增强功能，也可以使用市场上的一些领先图形库。 例如，您可以对其进行功能检测，如果可用，通过在渲染器构造函数中指定canvas选项将其与Three.js一起使用： 1234const canvasEl = document.querySelector("canvas");const canvas = ('OffscreenCanvas' in window) ? canvasEl.transferControlToOffscreen() : canvasEl;canvas.style = &#123; width: 0, height: 0 &#125;const renderer = new THREE.WebGLRenderer(&#123; canvas: canvas &#125;); 这里的问题是Three.js希望canvas具有style.width和style.height属性。OffscreenCanvas，与DOM完全分离，没有它，因此您需要自己提供它，或者通过将其删除或提供将这些值与原始画布尺寸相关联的逻辑。 这是一个如何在worker中运行基本Three.js动画的演示： 示例：use-with-lib 请记住，某些与DOM相关的API在Worker中并不容易获得，因此如果您想使用更高级的Three.js功能（如纹理），则可能需要更多变通方法。 结论如果您大量使用画布的图形功能，OffscreenCanvas可以积极影响您的应用程序的性能。使工作人员可以使用画布渲染上下文增加了Web应用程序的并行性，并更好地利用了多核系统。 OffscreenCanvas在Chrome 69中没有标记。它也在 Firefox 中开发。由于其API与常规canvas元素非常一致，因此您可以轻松地对其进行特征检测并将其用作渐进增强，而不会破坏现有的应用程序或库逻辑。它在图形和动画与画布周围的DOM紧密相关的所有情况下都具有性能优势。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>OffscreenCanvas</tag>
        <tag>Web Worker</tag>
      </tags>
  </entry>
</search>
