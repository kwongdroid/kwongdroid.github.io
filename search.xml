<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js模块化发展历程]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[模块化是指把一个复杂的系统分解到一个一个的模块。 模块化开发的优点：(1)代码复用，让我们更方便地进行代码管理、同时也便于后面代码的修改和维护。 (2)一个单独的文件就是一个模块，是一个单独的作用域，只向外暴露特定的变量和函数。这样可以避免污染全局变量，减少变量命名冲突。 js模块化规范有：CommonJS、AMD、CMD、ES6的模块系统。本文将依次介绍下每个规范。 一、早期：用script来引入js模块1234&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt; 缺点：(1)加载的时候会停止渲染网页，引入的js文件越多，网页失去响应的时间越长； (2)会污染全局变量； (3)js文件之间存在依赖关系，加载是有顺序的，依赖性最大的要放到最后去加载；当项目规模较大时，依赖关系变得错综复杂。 (4)要引入的js文件太多，不美观，代码难以管理。 二、CommonJS 规范是服务器端模块的规范，由nodejs推广使用。该规范的核心思想是：允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或module.exports 来导出需要暴露的接口。 CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过 exports.xx = xx 的方式导出，CommonJS2 在 CommonJS1 的基础上加入了module.exports = xx 的导出方式。 CommonJS 通常指 CommonJS2。 采用CommonJS 规范导入导出： 1234// 导出module.exports = moduleA.someFunc;// 导入const moduleA = require('./moduleA'); 实例： 12345678910//math.jsvar num = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //需要向外暴露的变量、函数 num: num, add: add&#125; 可以这样加载： 1234//引入自定义的模块时，参数包含路径，可省略.js//引入核心模块时，不需要带路径，如var http = require("http");var math = require('./math');math.add(1, 2)//3 实际上，从上面的例子就可以看出，math.add(1,2)必须要等待math.js加载完成，即require是同步的。 在服务器端，模块文件保存在本地磁盘，等待时间就是磁盘的读取时间。但对于浏览器而言，由于模块都放在服务器端，等待时间取决于网上的快慢。因此更合理的方案是异步加载模块。 缺点：(1)不能并行加载模块，会阻塞浏览器加载； (2)代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5； 三、AMD和require.jsAMD：异步模块定义。上面已经介绍过，CommonJS是服务器端模块的规范，主要是为了JS在后端的表现制定的，不太适合前端。而AMD就是要为前端JS的表现制定规范。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是require.js（还有个js库：curl.js）。实际上AMD 是 require.js在推广过程中对模块定义的规范化的产出。 AMD采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 require.js也采用require()语句加载模块，但是不同于CommonJS： 12345678// 定义一个模块define('module', ['dep'], function (dep) &#123; return exports;&#125;);// 导入和使用require(['module'], function (module) &#123;&#125;); 上面示例中的代码改写成AMD形式： math.js定义一个模块: 1234567define('math', ['jquery'], function (jquery) &#123;//引入jQuery模块 return &#123; add: function (x, y) &#123; return x + y; &#125; &#125;;&#125;); 导入和使用： 123require(['math'], function (math) &#123; math.add(1, 2)&#125;) math.add()与加载math模块不是同步的，不会阻塞浏览器的加载。 四、CMD和sea.jsCMD：通用模块定义。 国内的玉伯大佬写了sea.js，实际上CMD就是 sea.js在推广过程中对模块定义的规范化的产出。 123define(function (require, exports, module) &#123; // 模块代码&#125;); 说明： require：可以把其他模块导入进来的一个参数； exports：可以把模块内的一些属性和方法导出的； module： 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 上面示例中的代码改写成AMD形式： 1234567891011define(function (require, exports, module) &#123; var add = function (a, b) &#123; return a + b; &#125; exports.add = add;&#125;)//导入和使用seajs.use(['math.js'], function (math) &#123; var sum = math.add(1, 2);&#125;); CMD与AMD的不同的在于：(1)AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require： 12345678910111213141516171819//AMD推崇的依赖关系前置：在定义模块时就要声明要依赖的模块define(['a', 'b', 'c', 'd'], function (a, b, c, d) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处省略100行 ... b.doSomething() ...&#125;)//CMD推崇依赖就近，按需加载，只有在用到某个模块时再去requiredefine(function (require, exports, modules) &#123; var a = require('a'); a.doSomething(); // 此处省略100行 ... var b = require("b");//按需加载 b.doSomething(); ...&#125;) (2)AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。 对于依赖的模块，AMD是提前执行，CMD是延迟执行。 具体细节可点击与 RequireJS 的异同 五、ES6模块化ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 在 ES6 中，使用export关键字来导出模块，使用import关键字引用模块。但是浏览器还没有完全兼容，需要使用babel转换成ES5。 12345678// 导出export function hello() &#123; &#125;;export default &#123; // ...&#125;;// 导入import &#123; readFile &#125; from 'fs';import React from 'react'; 使用import导入模块时，需要知道要加载的变量名或函数名。 在ES6中还提供了export default，为模块指定默认输出.对应导入模块import时，不需要使用大括号。 上面示例中的代码改写成ES6形式： 123456789101112//math.jsvar num = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; num, add &#125;;//导入import &#123; num, add &#125; from './math';function test(ele) &#123; ele.textContent = add(1 + num);&#125; 缺点浏览器还没有完全兼容，必须通过工具转换成标准的 ES5 后才能正常运行。 小结本文从script引入js文件讲起，到服务器端模块的规范CommonJs，再到推崇依赖前置的浏览器端模块的规范AMD、推崇依赖就近的浏览器端模块的规范CMD，最后介绍了ES6的模块化。每个介绍中都有各规范基本的用法和一个示例。如有问题，欢迎指正。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-asset-image插件引用本地图片无法显示]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F%E4%BD%BF%E7%94%A8hexo-asset-image%E6%8F%92%E4%BB%B6%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[启用文章资源文件夹功能： 1.修改站点配置文件_config.yml：post_asset_folder: true 2.安装一个可以上传本地图片的插件：npm install hexo-asset-image --save 3.以后使用hexo new &#39;xxxx&#39;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 4.当我们在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![](图片名.jpg) 在文章里面插入图片，hexo g生成的时候总会在图片前面插一个.io，hexo s运行后图片并没有正常显示出来，在网上查找后发现是hexo-asset-image这个插件的bug，hexo版本3.0以上获取网站url的方式与3.0以下有些不同。 解决办法：打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行gulp项目报错：AssertionError [ERR_ASSERTION]: Task function must be specified]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F%E8%BF%90%E8%A1%8Cgulp%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%EF%BC%9AAssertionError-ERR-ASSERTION-Task-function-must-be-specified%2F</url>
    <content type="text"><![CDATA[今天写了一篇文章正准备发布，生成静态资源文件后使用gulp bulid压缩代码，但是一运行：gulp 出现了这个错误： 12345678910111213141516$ gulp buildassert.js:339 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (E:\Documents\GitHub\blog\node_modules\undertaker\lib\set-task.js:10:3) at Gulp.task (E:\Documents\GitHub\blog\node_modules\undertaker\lib\task.js:13:8) at Object.&lt;anonymous&gt; (E:\Documents\GitHub\blog\gulpfile.js:43:6) at Module._compile (internal/modules/cjs/loader.js:776:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Module.require (internal/modules/cjs/loader.js:690:17) at require (internal/modules/cjs/helpers.js:25:18) gulp项目需要全局安装gulp和项目内安装gulp 通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 123$ gulp -vCLI version: 3.9.1Local version: 4.0.2 查看package.json文件果然：&quot;gulp&quot;: &quot;^4.0.2&quot;, 因为本地的gulp更新到了版本4，而gulpfile.js用的是gulp3.9.1的语法 解决方案一：npm i gulp@3.9.1 重新安装gulp到3.9.1版 解决方案二：按gulp4的语法重写gulpfile.js任务列表]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OffscreenCanvas - 使用Web Worker加速您的Canvas操作]]></title>
    <url>%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2FOffscreenCanvas-%E4%BD%BF%E7%94%A8Web-Worker%E5%8A%A0%E9%80%9F%E6%82%A8%E7%9A%84Canvas%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[现在，您可以使用OffscreenCanvas从主线程渲染图形！ Canvas是一种在屏幕上绘制各种图形的流行方式，也是WebGL世界的切入点。它可用于绘制形状，图像，运行动画，甚至显示和处理视频内容。它通常用于在富媒体网络应用程序和在线游戏中创建出色的用户体验。 它是可编写脚本的，这意味着画布上绘制的内容可以通过编程方式创建，例如，在JavaScript中。这赋予画布很大的灵活性。 同时，在现代网站中，脚本执行是用户响应问题最常见的 来源之一。因为画布逻辑和渲染发生在与用户交互相同的线程上，动画中涉及的（有时很重）计算会损害应用程序的真实和感知性能。 幸运的是，OffscreenCanvas 是对这种威胁的回应！ 到目前为止，画布绘制功能与&lt;canvas&gt;元素绑定，这意味着它直接取决于DOM。顾名思义，OffscreenCanvas通过将其移出屏幕来解耦DOM和Canvas API。 由于这种解耦，OffscreenCanvas的渲染与DOM完全分离，因此在常规画布上提供了一些速度提升，因为两者之间没有同步。但更重要的是，它可以在Web Worker中使用，即使没有可用的DOM。这可以实现各种有趣的用例。 在Worker中使用OffscreenCanvasWorker 是网络的线程版本 - 它们允许您在后台运行任务。将一些脚本移动到Worker可以为应用程序提供更多空间，以便在主线程上执行用户关键任务。到目前为止，没有办法在Worker中使用Canvas API，因为没有可用的DOM。 OffscreenCanvas不依赖于DOM，因此可以使用它。在这里，我使用OffscreenCanvas来计算worker中的渐变颜色： 12345678910111213141516// file: worker.jsfunction getGradientColor(percent) &#123; const canvas = new OffscreenCanvas(100, 1); const ctx = canvas.getContext('2d'); const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0); gradient.addColorStop(0, 'red'); gradient.addColorStop(1, 'blue'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, ctx.canvas.width, 1); const imgd = ctx.getImageData(0, 0, ctx.canvas.width, 1); const colors = imgd.data.slice(percent * 4, percent * 4 + 4); return `rgba($&#123;colors[0]&#125;, $&#123;colors[1]&#125;, $&#123;colors[2]&#125;, $&#123;colors[])`;&#125;getGradientColor(40); // rgba(152, 0, 104, 255 ) 取消阻止主线程将大量计算移动到Worker时，可以释放主线程上的大量资源，这会变得更加有趣。我们可以使用transferControlToOffscreen 方法将常规画布镜像到OffscreenCanvas实例。应用于OffscreenCanvas的操作将自动在源画布上呈现。 123const offscreen = document.querySelector('canvas').transferControlToOffscreen();const worker = new Worker('myworkerurl.js');worker.postMessage(&#123; canvas: offscreen &#125;, [offscreen]); OffscreenCanvas是可转让的。除了将其指定为消息中的字段之外，还需要将其作为postMessage（转移）中的第二个参数传递，以便可以在Worker上下文中使用它。 在下面的示例中，当颜色主题发生变化时会发生“繁重计算” - 即使在快速桌面上也应该花费几毫秒。您可以选择在主线程或Worker线程上运行动画。在主线程的情况下，当繁重的任务运行时，您无法与按钮交互 - 线程被阻止。对于Worker，对UI响应性没有影响。 示例：keep-ui-responsive 它也是另一种方式：繁忙的主线程不会影响在worker上运行的动画。尽管有主要的线程流量，您仍可以使用此功能来避免视觉抖动并保证流畅的动画： 示例 在常规画布的情况下，当主线程被人为地过度工作时动画停止，而基于Worker的OffscreenCanvas播放顺利。 与流行的库一起使用由于OffscreenCanvas API通常与常规Canvas元素兼容，因此您可以轻松地将其用作渐进增强功能，也可以使用市场上的一些领先图形库。 例如，您可以对其进行功能检测，如果可用，通过在渲染器构造函数中指定canvas选项将其与Three.js一起使用： 1234const canvasEl = document.querySelector("canvas");const canvas = ('OffscreenCanvas' in window) ? canvasEl.transferControlToOffscreen() : canvasEl;canvas.style = &#123; width: 0, height: 0 &#125;const renderer = new THREE.WebGLRenderer(&#123; canvas: canvas &#125;); 这里的问题是Three.js希望canvas具有style.width和style.height属性。OffscreenCanvas，与DOM完全分离，没有它，因此您需要自己提供它，或者通过将其删除或提供将这些值与原始画布尺寸相关联的逻辑。 这是一个如何在worker中运行基本Three.js动画的演示： 示例：use-with-lib 请记住，某些与DOM相关的API在Worker中并不容易获得，因此如果您想使用更高级的Three.js功能（如纹理），则可能需要更多变通方法。 结论如果您大量使用画布的图形功能，OffscreenCanvas可以积极影响您的应用程序的性能。使工作人员可以使用画布渲染上下文增加了Web应用程序的并行性，并更好地利用了多核系统。 OffscreenCanvas在Chrome 69中没有标记。它也在 Firefox 中开发。由于其API与常规canvas元素非常一致，因此您可以轻松地对其进行特征检测并将其用作渐进增强，而不会破坏现有的应用程序或库逻辑。它在图形和动画与画布周围的DOM紧密相关的所有情况下都具有性能优势。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>Web Worker</tag>
      </tags>
  </entry>
</search>
