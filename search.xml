<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js模块化发展历程]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[模块化是指把一个复杂的系统分解到一个一个的模块。 模块化开发的优点：(1)代码复用，让我们更方便地进行代码管理、同时也便于后面代码的修改和维护。 (2)一个单独的文件就是一个模块，是一个单独的作用域，只向外暴露特定的变量和函数。这样可以避免污染全局变量，减少变量命名冲突。 js模块化规范有：CommonJS、AMD、CMD、ES6的模块系统。本文将依次介绍下每个规范。 一、早期：用script来引入js模块1234&lt;script type="text/javascript" src="a.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="b.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="c.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt; 缺点：(1)加载的时候会停止渲染网页，引入的js文件越多，网页失去响应的时间越长； (2)会污染全局变量； (3)js文件之间存在依赖关系，加载是有顺序的，依赖性最大的要放到最后去加载；当项目规模较大时，依赖关系变得错综复杂。 (4)要引入的js文件太多，不美观，代码难以管理。 二、CommonJS 规范是服务器端模块的规范，由nodejs推广使用。该规范的核心思想是：允许模块通过require方法来同步加载所要依赖的其他模块，然后通过 exports 或module.exports 来导出需要暴露的接口。 CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过 exports.xx = xx 的方式导出，CommonJS2 在 CommonJS1 的基础上加入了module.exports = xx 的导出方式。 CommonJS 通常指 CommonJS2。 采用CommonJS 规范导入导出： 1234// 导出module.exports = moduleA.someFunc;// 导入const moduleA = require('./moduleA'); 实例： 12345678910//math.jsvar num = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //需要向外暴露的变量、函数 num: num, add: add&#125; 可以这样加载： 1234//引入自定义的模块时，参数包含路径，可省略.js//引入核心模块时，不需要带路径，如var http = require("http");var math = require('./math');math.add(1, 2)//3 实际上，从上面的例子就可以看出，math.add(1,2)必须要等待math.js加载完成，即require是同步的。 在服务器端，模块文件保存在本地磁盘，等待时间就是磁盘的读取时间。但对于浏览器而言，由于模块都放在服务器端，等待时间取决于网上的快慢。因此更合理的方案是异步加载模块。 缺点：(1)不能并行加载模块，会阻塞浏览器加载； (2)代码无法直接运行在浏览器环境下，必须通过工具转换成标准的 ES5； 三、AMD和require.jsAMD：异步模块定义。上面已经介绍过，CommonJS是服务器端模块的规范，主要是为了JS在后端的表现制定的，不太适合前端。而AMD就是要为前端JS的表现制定规范。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是require.js（还有个js库：curl.js）。实际上AMD 是 require.js在推广过程中对模块定义的规范化的产出。 AMD采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 require.js也采用require()语句加载模块，但是不同于CommonJS： 12345678// 定义一个模块define('module', ['dep'], function (dep) &#123; return exports;&#125;);// 导入和使用require(['module'], function (module) &#123;&#125;); 上面示例中的代码改写成AMD形式： math.js定义一个模块: 1234567define('math', ['jquery'], function (jquery) &#123;//引入jQuery模块 return &#123; add: function (x, y) &#123; return x + y; &#125; &#125;;&#125;); 导入和使用： 123require(['math'], function (math) &#123; math.add(1, 2)&#125;) math.add()与加载math模块不是同步的，不会阻塞浏览器的加载。 四、CMD和sea.jsCMD：通用模块定义。 国内的玉伯大佬写了sea.js，实际上CMD就是 sea.js在推广过程中对模块定义的规范化的产出。 123define(function (require, exports, module) &#123; // 模块代码&#125;); 说明： require：可以把其他模块导入进来的一个参数； exports：可以把模块内的一些属性和方法导出的； module： 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 上面示例中的代码改写成AMD形式： 1234567891011define(function (require, exports, module) &#123; var add = function (a, b) &#123; return a + b; &#125; exports.add = add;&#125;)//导入和使用seajs.use(['math.js'], function (math) &#123; var sum = math.add(1, 2);&#125;); CMD与AMD的不同的在于：(1)AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require： 12345678910111213141516171819//AMD推崇的依赖关系前置：在定义模块时就要声明要依赖的模块define(['a', 'b', 'c', 'd'], function (a, b, c, d) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处省略100行 ... b.doSomething() ...&#125;)//CMD推崇依赖就近，按需加载，只有在用到某个模块时再去requiredefine(function (require, exports, modules) &#123; var a = require('a'); a.doSomething(); // 此处省略100行 ... var b = require("b");//按需加载 b.doSomething(); ...&#125;) (2)AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。 对于依赖的模块，AMD是提前执行，CMD是延迟执行。 具体细节可点击与 RequireJS 的异同 五、ES6模块化ES6在语言的层面上实现了模块化。浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 在 ES6 中，使用export关键字来导出模块，使用import关键字引用模块。但是浏览器还没有完全兼容，需要使用babel转换成ES5。 12345678// 导出export function hello() &#123; &#125;;export default &#123; // ...&#125;;// 导入import &#123; readFile &#125; from 'fs';import React from 'react'; 使用import导入模块时，需要知道要加载的变量名或函数名。 在ES6中还提供了export default，为模块指定默认输出.对应导入模块import时，不需要使用大括号。 上面示例中的代码改写成ES6形式： 123456789101112//math.jsvar num = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; num, add &#125;;//导入import &#123; num, add &#125; from './math';function test(ele) &#123; ele.textContent = add(1 + num);&#125; 缺点浏览器还没有完全兼容，必须通过工具转换成标准的 ES5 后才能正常运行。 小结本文从script引入js文件讲起，到服务器端模块的规范CommonJs，再到推崇依赖前置的浏览器端模块的规范AMD、推崇依赖就近的浏览器端模块的规范CMD，最后介绍了ES6的模块化。每个介绍中都有各规范基本的用法和一个示例。如有问题，欢迎指正。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行gulp项目报错：AssertionError [ERR_ASSERTION]: Task function must be specified]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%2F%E8%BF%90%E8%A1%8Cgulp%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%EF%BC%9AAssertionError-ERR-ASSERTION-Task-function-must-be-specified%2F</url>
    <content type="text"><![CDATA[今天写了一篇文章正准备发布，生成静态资源文件后使用gulp bulid压缩代码，但是一运行：gulp 出现了这个错误： 12345678910111213141516$ gulp buildassert.js:339 throw err; ^AssertionError [ERR_ASSERTION]: Task function must be specified at Gulp.set [as _setTask] (E:\Documents\GitHub\blog\node_modules\undertaker\lib\set-task.js:10:3) at Gulp.task (E:\Documents\GitHub\blog\node_modules\undertaker\lib\task.js:13:8) at Object.&lt;anonymous&gt; (E:\Documents\GitHub\blog\gulpfile.js:43:6) at Module._compile (internal/modules/cjs/loader.js:776:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Module.require (internal/modules/cjs/loader.js:690:17) at require (internal/modules/cjs/helpers.js:25:18) gulp项目需要全局安装gulp和项目内安装gulp 通过 gulp -v 查看全局gulp 和本地项目的gulp版本： 123$ gulp -vCLI version: 3.9.1Local version: 4.0.2 查看package.json文件果然：&quot;gulp&quot;: &quot;^4.0.2&quot;, 因为本地的gulp更新到了版本4，而gulpfile.js用的是gulp3.9.1的语法 解决方案一：npm i gulp@3.9.1 重新安装gulp到3.9.1版 解决方案二：按gulp4的语法重写gulpfile.js任务列表]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>
